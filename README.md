# Qflow-Install
Installation guide (Shell script)

qflow is an open-source tool for implementation from RTL to GDSII. It has simple push-button flow to implement the digital design. 

Tools are integrated with the qflow: 
1. Yosys
2. Graywolf
3. qrouter
4. Magic
5. netgen
6. qflow

![Qflow1](https://github.com/RukmiChavda/Qflow-Install/assets/82014536/2d21c04a-c787-4e10-b830-28e078aad933)


**yosys**
-> Yosys is a Verilog HDL synthesis tool. This means that it takes a behavioural design description as input and generates an RTL, logical gate, or physical gate-level description of the design as output.
-> Yosys’ main strengths are behavioural and RTL synthesis. 
-> A wide range of commands (synthesis passes) exists within Yosys that can be used to perform a wide range of synthesis tasks within the domain of behavioural, RTL, and logic synthesis. 
-> Yosys is designed to be extensible and therefore is a good basis for implementing custom synthesis tools for specialized tasks.
-> Yosys uses two different internal formats. The first is used to store an abstract syntax tree (AST) of a Verilog input file. This format is simply called AST and is generated by the Verilog Frontend. This data structure is consumed by a subsystem called AST Frontend1.
-> This AST Frontend then generates a design in Yosys’ main internal format, the
Register-Transfer-Level-Intermediate-Language (RTLIL) representation. It does that by first performing several simplifications within the AST representation and then generating RTLIL from the simplified AST data structure. 
-> The RTLIL representation is used by all passes as input and outputs.


**graywolf**
-> TimberWolf was developed at Yale University and was distributed as open-source for
a time until it was taken commercially. 
-> The last open-source version of TimberWolf does not perform detail routing but is a professional-grade placement tool. 
-> Graywolf is mainly used for the pin placement of the chip. 
-> It auto-places the pins by default but the user can also define the pin placement manually.


**qrouter**
-> Qrouter is a tool to generate the physical connection using metal layers and also
generates the netlist. 
-> It is a maze router, otherwise known as an "over-the-cell" router or "sea-of-gates" router. That is, unlike a channel router, it begins with a description of placed standard cells, usually packed together at minimum spacing, and places metal routes over the standard cells. 
-> Qrouter uses the open standard LEF and DEF formats as file input and output.
-> It takes the cell definitions from a LEF file and analyzes the geometry for each cell to determine contact points and route obstructions. It then reads the cell placement, pin placement, and netlist from a DEF file, performs the detailed route, and writes an annotated DEF file as output. 
-> Qrouter is based on the standard Lee maze router algorithm.


**Magic**
-> Magic is a venerable VLSI layout tool, written in 1980 at Berkeley by John
Ousterhout, now famous primarily for writing the scripting interpreter language Tcl. -> Due largely in part to its liberal Berkeley open-source license, magic has remained popular with universities and small companies. 
-> The open-source license has allowed VLSI engineers with a bent toward programming to implement clever ideas and help magic stay abreast of fabrication technology.
-> It is the well-thought-out core algorithms that lend to magic the greatest part of its popularity. 
-> Magic is widely cited as being the easiest tool to use for circuit layout, even for people who ultimately rely on commercial tools for their product design flow.


**Netgen**
-> Netgen is a tool for comparing netlists, a process known as LVS, which stands for
"Layout vs. Schematic". 
-> This is an important step in the integrated circuit design flow, ensuring that the geometry that has been laid out matches the expected circuit. 
-> Very small circuits can bypass this step by confirming circuit operation through extraction and simulation. 
-> Very large digital circuits are usually generated by tools from high-level descriptions, using compilers that ensure the correct layout geometry. The greatest need for LVS is in large analog or mixed-signal circuits that cannot be simulated in a reasonable time.
-> Even for small circuits, LVS can be done much faster than simulation and provides feedback that makes it easier to find an error than a simulation.
